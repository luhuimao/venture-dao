// Whole-script strict mode syntax
"use strict";

/**
MIT License

Copyright (c) 2020 Openlaw

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 */

// Whole-script strict mode syntax
"use strict";

const {
    toBN,
    toWei,
    fromUtf8,
    fromAscii,
    unitPrice,
    UNITS,
    ETH_TOKEN,
    sha3,
    numberOfUnits,
    maximumChunks,
    maxAmount,
    maxUnits
} = require("../../utils/contract-util");

const {
    fundingpoolExtensionAclFlagsMap,
    bankExtensionAclFlagsMap,
    daoAccessFlagsMap,
    entryDao,
    entryFundingPool,
    calculateFlagValue
} = require("../../utils/access-control-util");

const { extensionsIdsMap, adaptersIdsMap } = require("../../utils/dao-ids-util");
const hre = require("hardhat");
// const { getConfig } = require("../../migrations/configs/contracts.config");

import { deployDefaultDao, takeChainSnapshot, revertChainSnapshot, proposalIdGenerator, expect, expectRevert, web3 } from "../../utils/hh-util";

const proposalCounter = proposalIdGenerator().generator;

const getDefaultOptions = (options) => {
    return {
        minFundsForLP: 100,
        minFundsForGP: 1000,
        serviceFeeRatio: 5,
        unitPrice: unitPrice,
        nbUnits: numberOfUnits,
        votingPeriod: 5,
        gracePeriod: 1,
        tokenAddr: ETH_TOKEN,
        maxChunks: maximumChunks,
        maxAmount,
        maxUnits,
        chainId: 1,
        maxExternalTokens: 100,
        couponCreatorAddress: "0x7D8cad0bbD68deb352C33e80fccd4D8e88b4aBb8",
        kycMaxMembers: 1000,
        kycSignerAddress: "0x7D8cad0bbD68deb352C33e80fccd4D8e88b4aBb8",
        kycFundTargetAddress: "0x823A19521A76f80EC49670BE32950900E8Cd0ED3",
        deployTestTokens: true,
        erc20TokenName: "Test Token",
        erc20TokenSymbol: "TTK",
        erc20TokenDecimals: Number(0),
        erc20TokenAddress: UNITS,
        supplyTestToken1: 1000000,
        supplyTestToken2: 1000000,
        supplyPixelNFT: 100,
        supplyOLToken: toBN("1000000000000000000000000"),
        erc1155TestTokenUri: "1155 test token",
        maintainerTokenAddress: UNITS,
        // finalize: options.finalize === undefined || !!options.finalize,
        ...options, // to make sure the options from the tests override the default ones
        gasPriceLimit: "2000000000000",
        spendLimitPeriod: "259200",
        spendLimitEth: "2000000000000000000000",
        feePercent: "110",
        gasFixed: "50000",
        gelato: "0x1000000000000000000000000000000000000000",
    };
};

async function advanceTime(addr1, addr2, token) {

    for (var i = 0; i < 10; i++) {
        await token.transfer(addr2.address, 1);

        await token.connect(addr2).transfer(addr1.address, 1);

    }

    // await new Promise((resolve, reject) => {
    //     web3.currentProvider.send(
    //         {
    //             jsonrpc: "2.0",
    //             method: "evm_increaseTime",
    //             params: [time],
    //             id: new Date().getTime(),
    //         },
    //         (err, result) => {
    //             if (err) {
    //                 return reject(err);
    //             }
    //             return resolve(result);
    //         }
    //     );
    // });
}

function getProposalCounter() {
    return proposalCounter().next().value;
}

describe("Adapter - DistributeFunds", () => {
    before("deploy dao", async () => {
        let [owner, user1, user2, investor1, investor2, gp1, gp2, project_team1, project_team2, project_team3, rice_staker] = await hre.ethers.getSigners();
        this.owner = owner;
        this.user1 = user1;
        this.user2 = user2;
        this.investor1 = investor1;
        this.investor2 = investor2;
        this.gp1 = gp1;
        this.gp2 = gp2;
        this.project_team1 = project_team1;
        this.project_team2 = project_team2;
        this.project_team3 = project_team3;

        this.rice_staker = rice_staker;

        const { dao, adapters, extensions, testContracts } = await deployDefaultDao({
            owner: owner,
        });
        this.adapters = adapters;
        this.extensions = extensions;
        this.dao = dao;
        this.testContracts = testContracts;
        //test contract
        this.testtoken1 = testContracts.testToken1.instance
        this.testtoken2 = testContracts.testToken2.instance
        this.testRiceToken = testContracts.testRiceToken.instance
        //ext
        this.fundingPoolExt = this.extensions.fundingpoolExt.functions;
        this.gpdaoExt = this.extensions.gpDaoExt.functions;
        this.riceStakingExt = this.extensions.ricestakingExt.functions;
        //adapters
        this.streamingPayment = this.adapters.sablierAdapter.instance;
        this.manageMember = this.adapters.manageMemberAdapter.instance;
        this.allocationAdapter = this.adapters.allocation.instance;
        this.gpvoting = this.adapters.gpVotingAdapter.instance;
        this.distributefund = this.adapters.distributeFundAdapter.instance;
        this.fundingpoolAdapter = this.adapters.fundingpoolAdapter.instance;
        this.gpdaoAdapter = this.adapters.gpdaoAdapter.instance;
        this.stakingRiceAdapter = this.adapters.ricestakingAdapter.instance;
        this.snapshotId = await takeChainSnapshot();

        await this.testtoken1.transfer(investor1.address, hre.ethers.utils.parseEther("1000"));
        await this.testtoken1.transfer(investor2.address, hre.ethers.utils.parseEther("1000"));

        await this.testtoken1.transfer(gp1.address, hre.ethers.utils.parseEther("20000"));
        await this.testtoken1.transfer(gp2.address, hre.ethers.utils.parseEther("20000"));

        console.log(`investor1 testtoken1 balance: ${await this.testtoken1.balanceOf(investor1.address)}`);
        console.log(`investor2 testtoken1 balance: ${await this.testtoken1.balanceOf(investor2.address)}`);
        console.log(`gp1 testtoken1 balance: ${await this.testtoken1.balanceOf(gp1.address)}`);
        console.log(`gp2 testtoken1 balance: ${await this.testtoken1.balanceOf(gp2.address)}`);

        await this.testRiceToken.transfer(rice_staker.address, hre.ethers.utils.parseEther("20000"));
        console.log(`rice_staker rice balance: ${await this.testRiceToken.balanceOf(rice_staker.address)}`);

        console.log("dao member 1 addr: ", (await dao.getMemberAddress(0)));
        console.log("dao member 2 addr: ", (await dao.getMemberAddress(1)));
        //register new GP
        await this.gpdaoAdapter.registerNewGP(dao.address, this.gp1.address);
        await this.gpdaoAdapter.registerNewGP(dao.address, this.gp2.address);

        await this.fundingpoolAdapter.registerPotentialNewToken(dao.address, this.testtoken1.address);
    });

    beforeEach(async () => {
        await revertChainSnapshot(this.snapshotId);
        this.snapshotId = await takeChainSnapshot();
    });

    const depositToFundingPool = async (
        fundingpoolAdapter,
        dao,
        investor,
        amount,
        token) => {
        await token.connect(investor).approve(fundingpoolAdapter.address, amount);
        await fundingpoolAdapter.connect(investor).deposit(dao.address, amount);
    };

    const stakingRice = async (stakingRiceAdapter,
        dao,
        investor,
        amount,
        token) => {
        await token.connect(investor).approve(stakingRiceAdapter.address, amount);
        await stakingRiceAdapter.connect(investor).deposit(dao.address, amount, token.address);
    }

    const distributeFundsProposal = async (
        dao,
        distributeFundContract,
        requestedFundAmount,
        tradingOffTokenAmount,
        fullyReleasedDate,
        lockupDate,
        projectTeamAddr,
        projectTeamTokenAddr,
        sender,
        proposalId = null
    ) => {
        const newProposalId = proposalId ? proposalId : getProposalCounter();
        await distributeFundContract.connect(sender).submitProposal(
            dao.address,
            newProposalId,
            [projectTeamAddr, projectTeamTokenAddr],
            [requestedFundAmount, tradingOffTokenAmount, fullyReleasedDate, lockupDate]
        );
        return { proposalId: newProposalId };
    };

    // it("should be possible to register/remove new member by dao member", async () => {
    //     const dao = this.dao;
    //     const manageMember = this.manageMember;
    //     expect((await dao.isMember(this.owner.address))).equal(true);
    //     await manageMember.registerNewMember(dao.address, this.user1.address);
    //     expect((await dao.isMember(this.user1.address))).equal(true);
    //     expect((await dao.isMember(this.user2.address))).equal(false);
    //     await manageMember.removeMemberFromDAO(dao.address, this.user1.address);
    //     expect((await dao.isMember(this.user1.address))).equal(false);
    // });

    // it("should be not possible to register/remove a member by not a dao member", async () => {
    //     const dao = this.dao;
    //     const manageMember = this.manageMember;

    //     expect((await dao.isMember(this.user1.address))).equal(false);

    //     await expectRevert(
    //         manageMember.connect(this.user1).registerNewMember(dao.address, this.user1.address),
    //         "revert"
    //     );
    //     await expectRevert(manageMember.connect(this.user1).removeMemberFromDAO(dao.address, this.user1.address), "revert");

    // });

    it("should be not possible to submit a funding proposal by non dao member", async () => {
        const dao = this.dao;
        const distributeFundContract = this.distributefund
        const amountToDistribute = 10;
        const project_team1 = this.project_team1.address;


        const requestedFundAmount = hre.ethers.utils.parseEther("10000");
        const tradingOffTokenAmount = hre.ethers.utils.parseEther("50000");
        let blocktimestamp = (await hre.ethers.provider.getBlock("latest")).timestamp;
        const lockupDate = blocktimestamp;
        const fullyReleasedDate = lockupDate + 1000;
        const projectTeamAddr = this.project_team1.address;
        const projectTeamTokenAddr = this.testtoken2.address;

        await expectRevert(
            distributeFundsProposal(
                dao,
                distributeFundContract,
                requestedFundAmount,
                tradingOffTokenAmount,
                fullyReleasedDate,
                lockupDate,
                projectTeamAddr,
                projectTeamTokenAddr,
                this.user2
            ),
            "revert"
        );
    });

    it("should be possible to distribute funds to project team", async () => {
        const project_team1 = this.project_team1.address;
        const dao = this.dao;
        const fundingpoolAdapter = this.fundingpoolAdapter;
        const riceStakingAdapter = this.riceStakingAdapter;
        const fundingPoolExt = this.fundingPoolExt;
        const riceStakingExt = this.riceStakingExt;
        const gpdaoExt = this.gpdaoExt;
        const distributeFundContract = this.distributefund;
        const streamingPaymentContract = this.streamingPayment;
        //gp deposit funds
        await depositToFundingPool(this.fundingpoolAdapter, dao, this.gp1, hre.ethers.utils.parseEther("20000"), this.testtoken1);
        await depositToFundingPool(this.fundingpoolAdapter, dao, this.gp2, hre.ethers.utils.parseEther("20000"), this.testtoken1);
        //staking rice
        await stakingRice(this.stakingRiceAdapter, dao, this.rice_staker, hre.ethers.utils.parseEther("20000"), this.testRiceToken);

        console.log(`gp1 balance in funding pool: ${hre.ethers.utils.formatEther(
            (await fundingpoolAdapter.balanceOf(dao.address, this.gp1.address)).toString()
        )
            }`);
        console.log(`gp2 balance in funding pool: ${hre.ethers.utils.formatEther((await fundingpoolAdapter.balanceOf(dao.address, this.gp2.address)).toString())
            }`);

        console.log(`total supply ${hre.ethers.utils.formatEther((await fundingPoolExt.totalSupply()).toString())}`);
        console.log(`rice_staker balance: ${hre.ethers.utils.formatEther(
            (await riceStakingExt.balanceOf(this.rice_staker.address, this.testRiceToken.address)).toString())}`);

        expect((await gpdaoExt.isGeneralPartner(this.gp1.address))[0]).equal(true);
        expect((await gpdaoExt.isGeneralPartner(this.gp2.address))[0]).equal(true);
        console.log(`fundingpoolExt tt1 bal: ${hre.ethers.utils.formatEther((await this.testtoken1.balanceOf(this.extensions.fundingpoolExt.address)).toString())}`);

        // Submit distribute proposal
        const requestedFundAmount = hre.ethers.utils.parseEther("38000");
        const tradingOffTokenAmount = hre.ethers.utils.parseEther("50000");
        let blocktimestamp = (await hre.ethers.provider.getBlock("latest")).timestamp;
        const lockupDate = blocktimestamp + 24;
        console.log(`lockupDate: ${lockupDate}`);
        const fullyReleasedDate = lockupDate + 1000;
        const projectTeamAddr = this.project_team1.address;
        const projectTeamTokenAddr = this.testtoken2.address;

        await this.testtoken2.transfer(this.project_team1.address, tradingOffTokenAmount);
        console.log(`project token balance of project_team1:  ${hre.ethers.utils.formatEther(await this.testtoken2.balanceOf(this.project_team1.address))}`);
        await this.testtoken2.connect(this.project_team1).approve(distributeFundContract.address, tradingOffTokenAmount);
        console.log(`project token allowance of distributeFundContract : ${hre.ethers.utils.formatEther(await this.testtoken2.allowance(this.project_team1.address, distributeFundContract.address))}`);

        let { proposalId } = await distributeFundsProposal(
            dao,
            distributeFundContract,
            requestedFundAmount,
            tradingOffTokenAmount,
            fullyReleasedDate,
            lockupDate,
            projectTeamAddr,
            projectTeamTokenAddr,
            this.owner
        );
        console.log(`proposalId: ${proposalId}`);
        this.proposalId = proposalId;
        let projectTeamLockedTokenAmount = await distributeFundContract.projectTeamLockedTokens(dao.address, proposalId, projectTeamAddr);
        console.log(`projectTeam Locked Token Amount ${hre.ethers.utils.formatEther(projectTeamLockedTokenAmount)}`);
        console.log(`snap funds: ${hre.ethers.utils.formatEther((await fundingPoolExt.snapFunds()).toString())}`);
        // gp1 Vote YES on the proposal
        await this.gpvoting.connect(this.gp1).submitVote(dao.address, proposalId, 1);
        // gp2 Vote NO on the proposal
        await this.gpvoting.connect(this.gp2).submitVote(dao.address, proposalId, 1);
        await advanceTime(this.owner, this.user2, this.testtoken1);
        //get gp voting result
        const voteResults = await this.gpvoting.voteResult(dao.address, proposalId);

        //withdraw fund
        // await fundingpoolAdapter.connect(this.gp1).withdraw(dao.address, hre.ethers.utils.parseEther("10000"));
        // await fundingpoolAdapter.connect(this.gp2).withdraw(dao.address, hre.ethers.utils.parseEther("10000"));

        console.log(`voteResults: ${voteResults}`);
        console.log(`distributions status: ${(await distributeFundContract.distributions(dao.address, proposalId)).status}`);
        // Starts to process the proposal
        await distributeFundContract.processProposal(dao.address, proposalId);

        console.log(`project snap funds: ${hre.ethers.utils.formatEther((await fundingPoolExt.projectSnapFunds()).toString())}`);
        console.log(`project snap rice: ${hre.ethers.utils.formatEther((await riceStakingExt.getProjectSnapRice()).toString())}`);
        console.log(`total supply ${hre.ethers.utils.formatEther((await fundingPoolExt.totalSupply()).toString())}`);
        console.log(`fundingpoolExt tt1 bal: ${hre.ethers.utils.formatEther((await this.testtoken1.balanceOf(this.extensions.fundingpoolExt.address)).toString())}`);
        console.log(`distributions status: ${(await distributeFundContract.distributions(dao.address, proposalId)).status}`);
        projectTeamLockedTokenAmount = await distributeFundContract.projectTeamLockedTokens(dao.address, proposalId, projectTeamAddr);
        console.log(`projectTeam Locked Token Amount ${hre.ethers.utils.formatEther(projectTeamLockedTokenAmount)}`);
        console.log("project_team1 TestToken1 balance: ", hre.ethers.utils.formatEther((await this.testtoken1.balanceOf(project_team1)).toString()));
        expect((await this.testtoken1.balanceOf(project_team1))).equal(requestedFundAmount);

        let gp1BalanceInFundingPool = hre.ethers.utils.formatEther((await fundingPoolExt.balanceOf(this.gp1.address, this.testtoken1.address)).toString());
        let gp2BalanceInFundingPool = hre.ethers.utils.formatEther((await fundingPoolExt.balanceOf(this.gp2.address, this.testtoken1.address)).toString());

        console.log(`gp1 balance in funding pool:   ${gp1BalanceInFundingPool}`);
        console.log(`gp2 balance in funding pool: ${gp2BalanceInFundingPool}`);
        // expect(parseInt(gp1BalanceInFundingPool)).equal(19000 - 30000 / 2);
        // expect(parseInt(gp2BalanceInFundingPool)).equal(19000 - 30000 / 2);

        //allocation calculate
        //1. funding rewards
        const gp1fundingRewards = await this.allocationAdapter.getFundingRewards(dao.address,
            this.gp1.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const gp2fundingRewards = await this.allocationAdapter.getFundingRewards(dao.address,
            this.gp2.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const rice_staker_fundingRewards = await this.allocationAdapter.getFundingRewards(dao.address,
            this.rice_staker.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );

        //2. gp bonus
        const gp1Bonus = await this.allocationAdapter.getGPBonus(dao.address,
            this.gp1.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const gp2Bonus = await this.allocationAdapter.getGPBonus(dao.address,
            this.gp2.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const rice_staker_Bonus = await this.allocationAdapter.getGPBonus(dao.address,
            this.rice_staker.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );

        //3. rice staking rewards
        const gp1RiceStakingRewards = await this.allocationAdapter.getRiceRewards(
            dao.address,
            this.gp1.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const gp2RiceStakingRewards = await this.allocationAdapter.getRiceRewards(
            dao.address,
            this.gp2.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const riceStakingRewards = await this.allocationAdapter.getRiceRewards(
            dao.address,
            this.rice_staker.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );

        //check streaming payment balance
        const gp1fundingRewardsBal = await streamingPaymentContract.balanceOf(100000, this.gp1.address);
        const gp2fundingRewardsBal = await streamingPaymentContract.balanceOf(100001, this.gp2.address);
        const gp1GPBonusBal = await streamingPaymentContract.balanceOf(100002, this.gp1.address);
        const gp2GPBonusBal = await streamingPaymentContract.balanceOf(100003, this.gp2.address);
        const stakingRewardsBal = await streamingPaymentContract.balanceOf(100004, this.rice_staker.address);

        console.log(`gp1 fundingRewards balance: ${hre.ethers.utils.formatEther(gp1fundingRewardsBal)}`);
        console.log(`gp2 fundingRewards balance: ${hre.ethers.utils.formatEther(gp2fundingRewardsBal)}`);
        console.log(`gp1 GPBonus balance: ${hre.ethers.utils.formatEther(gp1GPBonusBal)}`);
        console.log(`gp2 GPBonus balance: ${hre.ethers.utils.formatEther(gp2GPBonusBal)}`);
        console.log(`staking Rewards balance: ${hre.ethers.utils.formatEther(stakingRewardsBal)}`);

        //withdraw from streaming payment
        await streamingPaymentContract.connect(this.gp1).withdrawFromStream(100000, gp1fundingRewardsBal);
        await streamingPaymentContract.connect(this.gp2).withdrawFromStream(100001, gp2fundingRewardsBal);
        await streamingPaymentContract.connect(this.gp1).withdrawFromStream(100002, gp1GPBonusBal);
        await streamingPaymentContract.connect(this.gp2).withdrawFromStream(100003, gp2GPBonusBal);
        await streamingPaymentContract.connect(this.rice_staker).withdrawFromStream(100004, stakingRewardsBal);

        //check project token balance 
        console.log(`project token balance for gp1: ${hre.ethers.utils.formatEther((await this.testtoken2.balanceOf(this.gp1.address)).toString())}`);
        console.log(`project token balance for gp2: ${hre.ethers.utils.formatEther((await this.testtoken2.balanceOf(this.gp2.address)).toString())}`);
        console.log(`project token balance for rice_staker: ${hre.ethers.utils.formatEther((await this.testtoken2.balanceOf(this.rice_staker.address)).toString())}`);

    });

    it("should be impossible to un-lock project tokens if voting passed and distribution done", async () => {
        const dao = this.dao;
        const distributeFundContract = this.distributefund;
        const voteResult = await this.gpvoting.voteResult(dao.address, this.proposalId);
        console.log("vote result: ", voteResult.state);
        expect(voteResult.state).equal(2)//voting passed
        let distributeStatus = (await distributeFundContract.distributions(dao.address, this.proposalId)).status;
        console.log("distributeStatus: ", distributeStatus);
        expect(distributeStatus).equal(2)//distribution done
        const projectTeamLockedTokenAmount = await distributeFundContract.projectTeamLockedTokens(dao.address, this.proposalId, this.project_team1.address);
        console.log(`projectTeamLockedTokenAmount: ${hre.ethers.utils.formatEther(projectTeamLockedTokenAmount)}`);
        await this.testtoken2.transfer(distributeFundContract.address, projectTeamLockedTokenAmount);
        await expectRevert(distributeFundContract.unLockProjectTeamToken(dao.address, this.proposalId), "revert");
    });

    it("should be impossible to distribute funds to project team if total funds smaller than requrested funds", async () => {
        const project_team2 = this.project_team2.address;
        const dao = this.dao;
        const fundingpoolAdapter = this.fundingpoolAdapter;
        const riceStakingAdapter = this.riceStakingAdapter;
        const fundingPoolExt = this.fundingPoolExt;
        const riceStakingExt = this.riceStakingExt;
        const gpdaoExt = this.gpdaoExt;
        const distributeFundContract = this.distributefund;
        const streamingPaymentContract = this.streamingPayment;
        //gp deposit funds
        await this.testtoken1.connect(this.owner).transfer(this.gp1.address, hre.ethers.utils.parseEther("2000"));
        await this.testtoken1.connect(this.owner).transfer(this.gp2.address, hre.ethers.utils.parseEther("2000"));
        console.log("gp1 tt1 bal: ", hre.ethers.utils.formatEther(await this.testtoken1.balanceOf(this.gp1.address)));
        console.log("gp2 tt1 bal:", hre.ethers.utils.formatEther(await this.testtoken1.balanceOf(this.gp2.address)));

        await depositToFundingPool(this.fundingpoolAdapter, dao, this.gp1, hre.ethers.utils.parseEther("2000"), this.testtoken1);
        await depositToFundingPool(this.fundingpoolAdapter, dao, this.gp2, hre.ethers.utils.parseEther("2000"), this.testtoken1);

        console.log(`gp1 balance in funding pool: ${hre.ethers.utils.formatEther(
            (await fundingpoolAdapter.balanceOf(dao.address, this.gp1.address)).toString()
        )
            }`);
        console.log(`gp2 balance in funding pool: ${hre.ethers.utils.formatEther((await fundingpoolAdapter.balanceOf(dao.address, this.gp2.address)).toString())
            }`);

        expect((await gpdaoExt.isGeneralPartner(this.gp1.address))[0]).equal(true);
        expect((await gpdaoExt.isGeneralPartner(this.gp2.address))[0]).equal(true);

        // Submit distribute proposal
        const requestedFundAmount = hre.ethers.utils.parseEther("3000");
        const tradingOffTokenAmount = hre.ethers.utils.parseEther("5000");
        let blocktimestamp = (await hre.ethers.provider.getBlock("latest")).timestamp;
        const lockupDate = blocktimestamp + 24;
        console.log(`lockupDate: ${lockupDate}`);
        const fullyReleasedDate = lockupDate + 1000;
        const projectTeamAddr = this.project_team2.address;
        const projectTeamTokenAddr = this.testtoken2.address;

        await this.testtoken2.transfer(this.project_team2.address, tradingOffTokenAmount);
        console.log(`project token balance of project_team2:  ${hre.ethers.utils.formatEther(await this.testtoken2.balanceOf(this.project_team2.address))}`);
        await this.testtoken2.connect(this.project_team2).approve(distributeFundContract.address, tradingOffTokenAmount);
        console.log(`project token allowance of distributeFundContract : ${hre.ethers.utils.formatEther(await this.testtoken2.allowance(this.project_team2.address, distributeFundContract.address))}`);

        let { proposalId } = await distributeFundsProposal(
            dao,
            distributeFundContract,
            requestedFundAmount,
            tradingOffTokenAmount,
            fullyReleasedDate,
            lockupDate,
            projectTeamAddr,
            projectTeamTokenAddr,
            this.owner
        );
        console.log(`distributions status: ${(await distributeFundContract.distributions(dao.address, proposalId)).status}`);

        console.log(`proposalId: ${proposalId}`);
        this.proposalId = proposalId;
        console.log(`snap funds: ${hre.ethers.utils.formatEther((await fundingPoolExt.snapFunds()).toString())}`);
        // gp1 Vote YES on the proposal
        await this.gpvoting.connect(this.gp1).submitVote(dao.address, proposalId, 1);
        // gp2 Vote YES on the proposal
        await this.gpvoting.connect(this.gp2).submitVote(dao.address, proposalId, 1);
        await advanceTime(this.owner, this.user2, this.testtoken1);
        //get gp voting result
        const voteResults = await this.gpvoting.voteResult(dao.address, proposalId);
        console.log(`voteResults: ${voteResults}`);
        //withdraw fund
        await fundingpoolAdapter.connect(this.gp1).withdraw(dao.address, hre.ethers.utils.parseEther("1000"));
        await fundingpoolAdapter.connect(this.gp2).withdraw(dao.address, hre.ethers.utils.parseEther("1000"));
        console.log(`fundingpoolExt tt1 bal: ${hre.ethers.utils.formatEther((await this.testtoken1.balanceOf(this.extensions.fundingpoolExt.address)).toString())}`);
        console.log(`total supply ${hre.ethers.utils.formatEther((await fundingPoolExt.totalSupply()).toString())}`);
        console.log(`gp1 balance in funding pool: ${hre.ethers.utils.formatEther(
            (await fundingpoolAdapter.balanceOf(dao.address, this.gp1.address)).toString()
        )
            }`);
        console.log(`gp2 balance in funding pool: ${hre.ethers.utils.formatEther((await fundingpoolAdapter.balanceOf(dao.address, this.gp2.address)).toString())
            }`);
        console.log("gp1 tt1 bal: ", hre.ethers.utils.formatEther(await this.testtoken1.balanceOf(this.gp1.address)));
        console.log("gp2 tt1 bal:", hre.ethers.utils.formatEther(await this.testtoken1.balanceOf(this.gp2.address)));
        console.log("project_team2 TestToken1 balance before processProposal: ", hre.ethers.utils.formatEther((await this.testtoken1.balanceOf(project_team2)).toString()));


        // Starts to process the proposal
        await distributeFundContract.processProposal(dao.address, proposalId);
        console.log(`project snap funds: ${hre.ethers.utils.formatEther((await fundingPoolExt.projectSnapFunds()).toString())}`);
        console.log(`project snap rice: ${hre.ethers.utils.formatEther((await riceStakingExt.getProjectSnapRice()).toString())}`);
        let distributeStatus = (await distributeFundContract.distributions(dao.address, proposalId)).status;
        console.log(`distributions status: ${distributeStatus}`);
        expect(distributeStatus).equal(3);
        console.log("project_team2 TestToken1 balance: ", hre.ethers.utils.formatEther((await this.testtoken1.balanceOf(project_team2)).toString()));
        expect((await this.testtoken1.balanceOf(project_team2))).equal(0);

        let gp1BalanceInFundingPool = hre.ethers.utils.formatEther((await fundingPoolExt.balanceOf(this.gp1.address, this.testtoken1.address)).toString());
        let gp2BalanceInFundingPool = hre.ethers.utils.formatEther((await fundingPoolExt.balanceOf(this.gp2.address, this.testtoken1.address)).toString());

        console.log(`gp1 balance in funding pool:   ${gp1BalanceInFundingPool}`);
        console.log(`gp2 balance in funding pool: ${gp2BalanceInFundingPool}`);
        // expect(parseInt(gp1BalanceInFundingPool)).equal(19000 - 30000 / 2);
        // expect(parseInt(gp2BalanceInFundingPool)).equal(19000 - 30000 / 2);

        //allocation calculate
        //1. funding rewards
        const gp1fundingRewards = await this.allocationAdapter.getFundingRewards(dao.address,
            this.gp1.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const gp2fundingRewards = await this.allocationAdapter.getFundingRewards(dao.address,
            this.gp2.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const rice_staker_fundingRewards = await this.allocationAdapter.getFundingRewards(dao.address,
            this.rice_staker.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );

        //2. gp bonus
        const gp1Bonus = await this.allocationAdapter.getGPBonus(dao.address,
            this.gp1.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const gp2Bonus = await this.allocationAdapter.getGPBonus(dao.address,
            this.gp2.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const rice_staker_Bonus = await this.allocationAdapter.getGPBonus(dao.address,
            this.rice_staker.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );

        //3. rice staking rewards
        const gp1RiceStakingRewards = await this.allocationAdapter.getRiceRewards(
            dao.address,
            this.gp1.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const gp2RiceStakingRewards = await this.allocationAdapter.getRiceRewards(
            dao.address,
            this.gp2.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );
        const riceStakingRewards = await this.allocationAdapter.getRiceRewards(
            dao.address,
            this.rice_staker.address,
            (await distributeFundContract.distributions(dao.address, proposalId)).tradingOffTokenAmount
        );

        console.log(`gp1 fundingRewards: ${hre.ethers.utils.formatEther(gp1fundingRewards)}, 
                    gpBonus: ${hre.ethers.utils.formatEther(gp1Bonus)},
                    RiceStakingRewards: ${hre.ethers.utils.formatEther(gp1RiceStakingRewards)}`
        );
        console.log(`gp2 fundingRewards: ${hre.ethers.utils.formatEther(gp2fundingRewards)},
                     gpBonus: ${hre.ethers.utils.formatEther(gp2Bonus)},
                     RiceStakingRewards: ${hre.ethers.utils.formatEther(gp2RiceStakingRewards)}`
        );
        console.log(`rice staker fundingRewards: ${hre.ethers.utils.formatEther(rice_staker_fundingRewards)},
                     gpBonus: ${hre.ethers.utils.formatEther(rice_staker_Bonus)},
                     riceStakingRewards: ${hre.ethers.utils.formatEther(riceStakingRewards)}`
        );

        //get streaming payment info #ID 100000
        console.log("get streaming payment info #ID 100000");
        let sdbinfo = await streamingPaymentContract.getStream(100000);
        console.log(`sender: ${sdbinfo.sender};
recipient: ${sdbinfo.recipient};
deposit : ${hre.ethers.utils.formatEther(sdbinfo.deposit)};
tokenAddress: ${sdbinfo.tokenAddress};
startTime : ${sdbinfo.startTime};
stopTime : ${sdbinfo.stopTime};
remainingBalance : ${hre.ethers.utils.formatEther(sdbinfo.remainingBalance)};
ratePerSecond : ${sdbinfo.ratePerSecond}`
        );
        //get streaming payment info #ID 100001
        console.log("get streaming payment info #ID 100001");
        sdbinfo = await streamingPaymentContract.getStream(100001);
        console.log(`sender: ${sdbinfo.sender};
recipient: ${sdbinfo.recipient};
deposit : ${hre.ethers.utils.formatEther(sdbinfo.deposit)};
tokenAddress: ${sdbinfo.tokenAddress};
startTime : ${sdbinfo.startTime};
stopTime : ${sdbinfo.stopTime};
remainingBalance : ${hre.ethers.utils.formatEther(sdbinfo.remainingBalance)};
ratePerSecond : ${sdbinfo.ratePerSecond}`
        );

        //get streaming payment info #ID 100001
        console.log("get streaming payment info #ID 100002");
        sdbinfo = await streamingPaymentContract.getStream(100002);
        console.log(`sender: ${sdbinfo.sender};
 recipient: ${sdbinfo.recipient};
 deposit : ${hre.ethers.utils.formatEther(sdbinfo.deposit)};
 tokenAddress: ${sdbinfo.tokenAddress};
 startTime : ${sdbinfo.startTime};
 stopTime : ${sdbinfo.stopTime};
 remainingBalance : ${hre.ethers.utils.formatEther(sdbinfo.remainingBalance)};
 ratePerSecond : ${sdbinfo.ratePerSecond}`
        );

        //check streaming payment balance
        const gp1fundingRewardsBal = await streamingPaymentContract.balanceOf(100000, this.gp1.address);
        const gp2fundingRewardsBal = await streamingPaymentContract.balanceOf(100001, this.gp2.address);
        const gp1GPBonusBal = await streamingPaymentContract.balanceOf(100002, this.gp1.address);
        const gp2GPBonusBal = await streamingPaymentContract.balanceOf(100003, this.gp2.address);
        const stakingRewardsBal = await streamingPaymentContract.balanceOf(100004, this.rice_staker.address);

        console.log(`gp1 fundingRewards balance: ${hre.ethers.utils.formatEther(gp1fundingRewardsBal)}`);
        console.log(`gp2 fundingRewards balance: ${hre.ethers.utils.formatEther(gp2fundingRewardsBal)}`);
        console.log(`gp1 GPBonus balance: ${hre.ethers.utils.formatEther(gp1GPBonusBal)}`);
        console.log(`gp2 GPBonus balance: ${hre.ethers.utils.formatEther(gp2GPBonusBal)}`);
        console.log(`staking Rewards balance: ${hre.ethers.utils.formatEther(stakingRewardsBal)}`);

        //withdraw from streaming payment
        await streamingPaymentContract.connect(this.gp1).withdrawFromStream(100000, gp1fundingRewardsBal);
        await streamingPaymentContract.connect(this.gp2).withdrawFromStream(100001, gp2fundingRewardsBal);
        await streamingPaymentContract.connect(this.gp1).withdrawFromStream(100002, gp1GPBonusBal);
        await streamingPaymentContract.connect(this.gp2).withdrawFromStream(100003, gp2GPBonusBal);
        await streamingPaymentContract.connect(this.rice_staker).withdrawFromStream(100004, stakingRewardsBal);

        //check project token balance 
        console.log(`project token balance for gp1: ${hre.ethers.utils.formatEther((await this.testtoken2.balanceOf(this.gp1.address)).toString())}`);
        console.log(`project token balance for gp2: ${hre.ethers.utils.formatEther((await this.testtoken2.balanceOf(this.gp2.address)).toString())}`);
        console.log(`project token balance for rice_staker: ${hre.ethers.utils.formatEther((await this.testtoken2.balanceOf(this.rice_staker.address)).toString())}`);

    });

    it("should be possible to un-lock project tokens if voting passed  but distribution failed", async () => {
        const dao = this.dao;
        const distributeFundContract = this.distributefund;
        const voteResult = await this.gpvoting.voteResult(dao.address, this.proposalId);
        console.log("vote result: ", voteResult.state);
        expect(voteResult.state).equal(2)//voting passed
        let distributeStatus = (await distributeFundContract.distributions(dao.address, this.proposalId)).status;
        console.log("distributeStatus: ", distributeStatus);
        expect(distributeStatus).equal(3)//distribution failed

        const projectTeamLockedTokens = await distributeFundContract.projectTeamLockedTokens(dao.address, this.proposalId, this.project_team2.address);
        console.log(`project_team2 project token Locked amount: ${hre.ethers.utils.formatEther(projectTeamLockedTokens)}`);
        console.log(`project_team2 project token bal: ${hre.ethers.utils.formatEther(await this.testtoken2.balanceOf(this.project_team2.address))}`);

        await distributeFundContract.connect(this.project_team2).unLockProjectTeamToken(dao.address, this.proposalId);
        console.log(`project_team2 project token bal: ${hre.ethers.utils.formatEther(await this.testtoken2.balanceOf(this.project_team2.address))}`);
        expect(projectTeamLockedTokens).equal((await this.testtoken2.balanceOf(this.project_team2.address)));
    });

    it("should be impossible submit proposal with same proposalId", async () => {
        const requestedFundAmount = hre.ethers.utils.parseEther("100");
        const tradingOffTokenAmount = hre.ethers.utils.parseEther("500");
        let blocktimestamp = (await hre.ethers.provider.getBlock("latest")).timestamp;
        const lockupDate = blocktimestamp + 24;
        const fullyReleasedDate = lockupDate + 1000;
        const projectTeamAddr = this.project_team1.address;
        const projectTeamTokenAddr = this.testtoken2.address;

        await this.testtoken2.transfer(this.project_team1.address, tradingOffTokenAmount);
        console.log(`project token balance of project_team1:  ${hre.ethers.utils.formatEther(await this.testtoken2.balanceOf(this.project_team1.address))}`);
        await this.testtoken2.connect(this.project_team1).approve(this.distributefund.address, tradingOffTokenAmount);
        console.log(`project token allowance of distributeFundContract : ${hre.ethers.utils.formatEther(await this.testtoken2.allowance(this.project_team1.address, this.distributefund.address))}`);
        await expectRevert(distributeFundsProposal(
            this.dao,
            this.distributefund,
            requestedFundAmount,
            tradingOffTokenAmount,
            fullyReleasedDate,
            lockupDate,
            projectTeamAddr,
            projectTeamTokenAddr,
            this.owner,
            this.proposalId
        ), "revert");
    });

    it("should be possible to un-lock project tokens if voting failed or tie", async () => {
        const dao = this.dao;
        const distributeFundContract = this.distributefund;

        //submite distribute proposal
        const requestedFundAmount = hre.ethers.utils.parseEther("1000");
        const tradingOffTokenAmount = hre.ethers.utils.parseEther("50000");
        let blocktimestamp = (await hre.ethers.provider.getBlock("latest")).timestamp;
        const lockupDate = blocktimestamp + 24;
        const fullyReleasedDate = lockupDate + 1000;
        const projectTeamAddr = this.project_team3.address;
        const projectTeamTokenAddr = this.testtoken2.address;

        await this.testtoken2.transfer(projectTeamAddr, tradingOffTokenAmount);
        await this.testtoken2.connect(this.project_team3).approve(this.distributefund.address, tradingOffTokenAmount);
        console.log(`project team project token amount: ${hre.ethers.utils.formatEther(await this.testtoken2.balanceOf(projectTeamAddr))}`);

        let { proposalId } = await distributeFundsProposal(
            dao,
            this.distributefund,
            requestedFundAmount,
            tradingOffTokenAmount,
            fullyReleasedDate,
            lockupDate,
            projectTeamAddr,
            projectTeamTokenAddr,
            this.owner
        );
        console.log(`new proposalID ${proposalId}`);
        await this.gpvoting.connect(this.gp1).submitVote(dao.address, proposalId, 2);
        await advanceTime(this.owner, this.user1, this.testtoken1);
        const voteResults = await this.gpvoting.voteResult(dao.address, proposalId);
        console.log(`voteResults: ${voteResults}`);

        let projectTeamLockedTokenAmount = await distributeFundContract.projectTeamLockedTokens(dao.address, proposalId, projectTeamAddr);
        console.log(`projectTeamLockedTokenAmount: ${hre.ethers.utils.formatEther(projectTeamLockedTokenAmount)}`);

        await distributeFundContract.processProposal(dao.address, proposalId);
        await distributeFundContract.connect(this.project_team3).unLockProjectTeamToken(dao.address, proposalId);

        projectTeamLockedTokenAmount = await distributeFundContract.projectTeamLockedTokens(dao.address, proposalId, projectTeamAddr);
        console.log(`projectTeamLockedTokenAmount: ${hre.ethers.utils.formatEther(projectTeamLockedTokenAmount)}`);

        const projectTeamProjectTokenBal = await this.testtoken2.balanceOf(projectTeamAddr);
        console.log(`projectTeam ProjectToken Bal: ${hre.ethers.utils.formatEther(projectTeamProjectTokenBal)}`);
        expect(projectTeamProjectTokenBal).equal(tradingOffTokenAmount)
    });
});
